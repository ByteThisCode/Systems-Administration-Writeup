# Shell Scripting

---------------
> [Back to Main](../../../)
---------------
## - Contents

0. [Useful Commands](#--useful-commands)
1. [Redirection](#--redirection)
2. [Filters](#--filters)
    * [cat](#--cat)  
    * [less](#--less)
    * [rev](#--rev)
    * [head/tail](#--headtail)
    * [cut](#--cut)
    * [sort](#--sort)
    * [uniq](#--uniq)
    * [wc](#--wc)
    * [grep](#--grep)
    * [tr](#--tr)
    * [sed](#--sed)
    * [awk](#--awk)
3. [Regex](#--regex)

---------------
## - Useful Commands

* `2>/dev/null` - Discard errors 

---------------
## - Redirection

Bash can disconnect predefined streams from the terminal and have the same file descriptor open on a different file.

* **stdout** redirection: `>` e `>>`
  * `ls > filename` - Writes the stdout of ls to the file filename, truncating it
  * `ls >> filename` - Writes the stdout of ls to the file filename, in append
* **stderror** redirection: `2>` e `2>>`
  * same as above

* Confluence of streams
  * `ls > filename 2>&1` - Redirect stderr into stdout and then stdout to file (Order matters!)

* **stdin** redirection: `<`
  * `sort < filename` - Dump the contents of the file to sort's stdin

  
**- Special Redirection**

* **Definitive redirection**: `exec`  

  * Ex: `exec 2>/dev/null`  

  Useful because open file descriptors are inherited by child processes:
  * Ex: `exec 3< filein 4> fileout 5<> filerw`  
    -Every reading made from fd 3 with `<&3` will read from filein  
    -Every writing made to fd 4 with `>&4` will write to fileout  
    -Fd 5 can be used for both reading and writing to filerw  
    -To close: `exec 3>&- 4>&- 5>&-`

* **Here documents**: `commands <<MARKER`
  Send text directly to a command until the chosen marker is inserted (case sensitive)
   ``` 
    Lorem ipsum dolor sit amet,  
    consectetur adipiscing elit.
    MARKER
    ```
  * For a single line the marker is not needed: `comand <<< "Single text line..."`

---------------
## - Filters

### - cat
  * Invoked without parameters copies stdin to stdout  
  * Invoked with one or more files produces their contents in sequence on stdout: `cat file1 file2`
  * `tac` - Prints the input lines (stdin or file) on stdout in reverse order, from last to first


### - less
  * Displays the contents of a file or a command output, one page at a time. Allows you to navigate both forward and backward through the file.  
  * You can move using up/down arrow or up/down page
  * Main commands: 
      ```
    F / Space bar - Move Forward one page  
    Ng - Go to the N-th line in the file  
    G - Go to the last line in the file  
    /pattern - Search forward for matching patterns
    ?pattern - Search backward for matching patterns
    n - Repeat previous search
    N - Repeat previous search in reverse direction
    q - To quit less
    ```

### - rev
  * Allows you to reverse the order of the characters of each line of the input stream towards the output stream  
  * Ex: `cat /etc/passwd | rev | cut -f1 -d: -s | rev`

### - head/tail
  * **head** is a filter that allows you to extract the initial part of a file (default first 10 lines)
      ```
    -c NUM - Produces the first NUM characters  
    -c -NUM - Produces the entire file except the last NUM characters 
    -n NUM - Produces the first NUM lines
    -n -NUM - Produces the entire file except the last NUM lines 
    ```
   
  * **tail** is a filter that allows you to extract the final part of a file (default last 10 lines)
      ```
    -c NUM - Produces the last NUM characters  
    -c +NUM - Produces the entire file starting with the NUM character 
    -n NUM - Produces the last NUM lines
    -n -NUM - Produces the entire file starting with the NUM lines
    -f - Keeps the file open and any new lines that are appended to it by other processes are displayed in real time
      -f --pid=PID - At the termination of the PID process also terminates tail 
      -f --retry / -F - Tail will keep trying until it opens the file (in case you are expecting a file generated by another process)
      ```

### - cut
  * Allows you to cut parts of lines
  * -c - Produces for each input line an output line consisting only of the characters listed. Ex:   `cut -cPOSITION [input_file]`
    ```
    cut -c15 - Returns only the 15th character
    cut -c8-30 - Returns the characters from the 8th to the 30th
    cut -c-30 - Returns characters up to the 30th
    cut -c8- - Returns the characters from the 8th onwards
    ```
  * Other options:
    * -d - Allows you to define a delimiter
    * -f - Allows you to select a field
    * `cut -dDELIMITER -fNUM`
    * Ex:  `cat /etc/passwd | cut -d: -f1 -s`
      * -s - It prevents lines that do not contain the delimiter from being output   
 

### - sort
  * Allows you to sort the lines of a stream (default lexical order)
  * Global behavior options:
      ```
      -u - Delete multiple entries (equivalent to sort | uniq)  
      -r - Reverse (descending order)  
      -R - Random (random permutation of lines)  
      -m - Merge of the file already sorted  
      -c - Check if the file is already sorted
      ```  
  * Other criteria:
      ```
      -b - Ignore leading spaces  
      -d - Only consider alphanumeric characters and spaces  
      -f - Ignore the difference between lowercase / uppercase  
      -n - Interpret strings of numbers by their numeric value  
      -h - Interpret "readable" numbers, such as 2K, 1G...
      ```
  * It can also search for sort keys in specific positions in the row:  
      ```
      -tSEP - Set SEP as separator between fields (default spaces)  
      -kKEY - Sorting key, if used more than once, sorts by the first key, if this equal by the second key, and so on
      ```  
    KEY is in the form (simplified) `F[.C] [,F[.C]] [OPTS]`
      * F = Field number  
      * C = Position (characters) in the field  
      * OPTS = One of the sorting options [bdfgiMhnRrV]
      * Ex: `sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n` (sort ip address list)

### - uniq
  * Eliminates consecutive duplicates  
      ```
      -c - It also indicates the number of rows packed into one (ocurrence number)
      -d - It shows only non-single entries
      ```
      
 ### - wc
  * (word count) is a count filter
      ```
      -l, --lines - Print the number of lines
      -w, --words - Print the number of words
      -m, --chars - Print the number of characters
      -c, --bytes - Print the number of bytes
      -L, --max-line-length - Print the length of the longest line
      ```
      
### - grep
  * Examines incoming lines of text and outputs those containing a pattern corresponding to a **regular expression**  
  * **egrep** modern version
  * Matching type check:  
      ```
      -E - Treats pattern as an extended regular expression  
      -F - Disable the RE and use the parameter as a literal string  
      -w, -x - Match whole word or whole line  
      -i - Ignores case for matching  
      ```  
  * Input check:  
      ```
      -r - Recursively searches all files in a folder  
      -f FILE - Takes patterns from file, one per line  
      ```
  * Output check:  
      ```
      -o - Print only the matched parts of a matching line, with each such part on a separate output line  
      -v - Prints out all the lines that do not matches the pattern  
      -l - Displays list of a filenames only
      -n - Display the matched lines and their line numbers
      -c - This prints only a count of the lines that match a pattern
      --line-buffered - disable buffering
      ```
      
### - tr
  * Replaces individual characters more quickly without regex, some examples:
    * `tr 'A-Z' 'a-z'` - Changes uppercase to lowercase  
    * `tr ';:.!?' ','` - Replaces any occurrence of the characters in the first set with ,
    * `tr ';:.!?' ',-'` - If the second set is more limited than the first set, its character is repeated enough to generate the 1: 1 match
    * `tr -d '\r'` - Eliminates any occurrence of the carriage return

### - sed
  * Stream EDitor, base format: `sed -e 'command'` or `sed -f 'script'`  
  * Substitution command: `sed 's/OLD_PATTERN/NEW_VALUE/[modifiers]'`  
    * Ex: `cat /etc/passwd | sed 's/^/Line:/'` - Insert string 'line:' at the beginning of each line of passwd
    * With -E the patterns are about those of egrep  
  * Substitution command modifier:
      ``` 
      i - Case sensitive
      g - Global, replaces all occurrences in the line
      NUM - Replaces only the NUMth occurrence 
      ```
  * Command line options:
      ```
      -i [suffix] - Edits the given file [backup with SUFFIX extension if provided]
      -u - Unbuffered
      ```
    
    
