# Shell Scripting

---------------
> [Back to Main](../../../)
---------------
## - Contents

0. [Useful Commands](#--useful-commands)
1. [Redirection](#--redirection)
2. [Filters](#--filters)
    * [cat](#--cat)  
    * [less](#--less)
    * [rev](#--rev)
    * [head/tail](#--headtail)
    * [cut](#--cut)
    * [sort](#--sort)
    * [uniq](#--uniq)
    * [wc](#--wc)
    * [grep](#--grep)
    * [tr](#--tr)
    * [sed](#--sed)
    * [awk](#--awk)
3. [Regex](#--regex)
4. [xargs](#--xargs)
5. [tee](#--tee)
6. [Process Substitution](#--process-substitution)
7. [Command Substitution](#--command-substitution)
8. [Multiple Files Tools](#--multiple-files-tools)
    * [diff](#--diff)   
    * [paste](#--paste)  
    * [join](#--join)  
9. [Quoting](#--quoting)  
10. [Pathname Expansion](#--pathname-expansion)  
11. [Brace Expansion](#--brace-expansion)  
12. [Variables](#--variables)
    * [Environment Variables](#--environment-variables)   
    * [Notable Variables](#--notable-variables)

---------------
## - Useful Commands

* `2>/dev/null` - Discard errors 

---------------
## - Redirection

Bash can disconnect predefined streams from the terminal and have the same file descriptor open on a different file.

* **stdout** redirection: `>` e `>>`
  * `ls > filename`     - Writes the stdout of ls to the file filename, truncating it
  * `ls >> filename`    - Writes the stdout of ls to the file filename, in append
* **stderror** redirection: `2>` e `2>>`
  * same as above

* Confluence of streams
  * `ls > filename 2>&1`   - Redirect stderr into stdout and then stdout to file (Order matters!)

* **stdin** redirection: `<`
  * `sort < filename`      - Dump the contents of the file to sort's stdin

  
**- Special Redirection**

* **Definitive redirection**: `exec`  

  * Ex: `exec 2>/dev/null`  

  Useful because open file descriptors are inherited by child processes:
  * Ex: `exec 3< filein 4> fileout 5<> filerw`  
    -Every reading made from fd 3 with `<&3` will read from filein  
    -Every writing made to fd 4 with `>&4` will write to fileout  
    -Fd 5 can be used for both reading and writing to filerw  
    -To close: `exec 3>&- 4>&- 5>&-`  

* **Here documents**: `commands <<MARKER`  
  Send text directly to a command until the chosen marker is inserted (case sensitive)  
   ``` 
    Lorem ipsum dolor sit amet,  
    consectetur adipiscing elit.
    MARKER
    ```
  * For a single line the marker is not needed: `comand <<< "Single text line..."`  

---------------
## - Filters

### - cat
  * Invoked without parameters copies stdin to stdout  
  * Invoked with one or more files produces their contents in sequence on stdout: `cat file1 file2`
  * `tac`   - Prints the input lines (stdin or file) on stdout in reverse order, from last to first


### - less
  * Displays the contents of a file or a command output, one page at a time. Allows you to navigate both forward and backward through the file.  
  * You can move using up/down arrow or up/down page
  * Main commands: 
      ```
    F / Space bar    - Move Forward one page  
    Ng               - Go to the N-th line in the file  
    G                - Go to the last line in the file  
    /pattern         - Search forward for matching patterns  
    ?pattern         - Search backward for matching patterns  
    n                - Repeat previous search  
    N                - Repeat previous search in reverse direction  
    q                - To quit less  
    ```

### - rev
  * Allows you to reverse the order of the characters of each line of the input stream towards the output stream  
  * Ex: `cat /etc/passwd | rev | cut -f1 -d: -s | rev`

### - head/tail
  * **head** is a filter that allows you to extract the initial part of a file (default first 10 lines)
      ```
    -c NUM        - Produces the first NUM characters  
    -c -NUM       - Produces the entire file except the last NUM characters 
    -n NUM        - Produces the first NUM lines  
    -n -NUM       - Produces the entire file except the last NUM lines  
    ```
   
  * **tail** is a filter that allows you to extract the final part of a file (default last 10 lines)
      ```
    -c NUM              - Produces the last NUM characters  
    -c +NUM             - Produces the entire file starting with the NUM character 
    -n NUM              - Produces the last NUM lines
    -n -NUM             - Produces the entire file starting with the NUM lines
    -f                  - Keeps the file open and any new lines that are appended to it by other processes are displayed in real time
      -f --pid=PID         - At the termination of the PID process also terminates tail 
      -f --retry / -F      - Tail will keep trying until it opens the file (in case you are expecting a file generated by another process)
      ```

### - cut
  * Allows you to cut parts of lines
  * `-c` - Produces for each input line an output line consisting only of the characters listed. Ex:   `cut -cPOSITION [input_file]`
    ```
    cut -c15            - Returns only the 15th character  
    cut -c8-30          - Returns the characters from the 8th to the 30th  
    cut -c-30           - Returns characters up to the 30th  
    cut -c8-            - Returns the characters from the 8th onwards  
    ```
  * Other options:
    * `-d`             - Allows you to define a delimiter  
    * `-f`             - Allows you to select a field  
    * `cut -dDELIMITER -fNUM`  
    * Ex:  `cat /etc/passwd | cut -d: -f1 -s`  
      * `-s` - It prevents lines that do not contain the delimiter from being output    
 

### - sort
  * Allows you to sort the lines of a stream (default lexical order)  
  * Global behavior options:  
      ```
      -u             - Delete multiple entries (equivalent to sort | uniq)  
      -r             - Reverse (descending order)  
      -R             - Random (random permutation of lines)  
      -m             - Merge of the file already sorted  
      -c             - Check if the file is already sorted  
      ```  
  * Other criteria:  
      ```
      -b             - Ignore leading spaces   
      -d             - Only consider alphanumeric characters and spaces   
      -f             - Ignore the difference between lowercase / uppercase  
      -n             - Interpret strings of numbers by their numeric value  
      -h             - Interpret "readable" numbers, such as 2K, 1G...  
      ```
  * It can also search for sort keys in specific positions in the row:   
      ```
      -tSEP          - Set SEP as separator between fields (default spaces)  
      -kKEY          - Sorting key, if used more than once, sorts by the first key, if this equal by the second key, and so on  
      ```  
    KEY is in the form (simplified) `F[.C] [,F[.C]] [OPTS]`  
      * F = Field number  
      * C = Position (characters) in the field  
      * OPTS = One of the sorting options [bdfgiMhnRrV]  
      * Ex: `sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n` (sort ip address list)  

### - uniq
  * Eliminates consecutive duplicates   
      ```
      -c             - It also indicates the number of rows packed into one (ocurrence number)  
      -d             - It shows only non-single entries  
      ```
      
 ### - wc
  * (word count) is a count filter
      ```
      -l, --lines             - Print the number of lines  
      -w, --words             - Print the number of words  
      -m, --chars             - Print the number of characters  
      -c, --bytes             - Print the number of bytes  
      -L, --max-line-length   - Print the length of the longest line  
      ```
      
### - grep
  * Examines incoming lines of text and outputs those containing a pattern corresponding to a **regular expression**  
  * **egrep** modern version  
  * Matching type check:  
      ```
      -E                - Treats pattern as an extended regular expression  
      -F                - Disable the RE and use the parameter as a literal string  
      -w, -x            - Match whole word or whole line  
      -i                - Ignores case for matching  
      ```  
  * Input check:  
      ```
      -r                - Recursively searches all files in a folder  
      -f FILE           - Takes patterns from file, one per line  
      ```
  * Output check:  
      ```
      -o                - Print only the matched parts of a matching line, with each such part on a separate output line  
      -v                - Prints out all the lines that do not matches the pattern  
      -l                - Displays list of a filenames only  
      -n                - Display the matched lines and their line numbers  
      -c                - This prints only a count of the lines that match a pattern  
      --line-buffered   - disable buffering  
      ```
      
### - tr
  * Replaces individual characters more quickly without regex, some examples:  
    * `tr 'A-Z' 'a-z'`     - Changes uppercase to lowercase   
    * `tr ';:.!?' ','`     - Replaces any occurrence of the characters in the first set with ,  
    * `tr ';:.!?' ',-'`    - If the second set is more limited than the first set, its character is repeated enough to generate the 1: 1 match  
    * `tr -d '\r'`         - Eliminates any occurrence of the carriage return  

### - sed
  * Stream EDitor, base format: `sed -e 'command'` or `sed -f 'script'`  
  * Substitution command: `sed 's/OLD_PATTERN/NEW_VALUE/[modifiers]'`  
    * Ex: `cat /etc/passwd | sed 's/^/Line:/'` - Insert string 'line:' at the beginning of each line of passwd  
    * With -E the patterns are about those of egrep  
  * Substitution command modifier:  
      ``` 
      i        - Case sensitive  
      g        - Global, replaces all occurrences in the line  
      NUM      - Replaces only the NUMth occurrence  
      ```
  * Command line options:  
      ```
      -i [suffix]    - Edits the given file [backup with SUFFIX extension if provided]  
      -u             - Unbuffered  
      ```
  
  * Examples:  
      ```
      (file : hi hi hi)  
      bash$ cat file | sed -e 's/hi/hello/'  
         hello hi hi  
      bash$ cat file | sed -e 's/hi/hello/g'  
         hello hello hello  
      ```
      
    
### - awk
  * Works on programs that contain rules comprised of patterns and actions  
  * The action is executed on the text that matches the pattern  
  * Default: prints the number of the chosen field, provided it is separated from the previous one by a number of blanks  
  * Ex: `cat /etc/passwd | awk '{print $2}'` - Print the second field of the file  
  * **-F separator** - To specify a file separator  
  * Identifiers:  
      ```
      $0: Represents the entire line of text  
      $1: Represents the first field  
      $2: Represents the second field  
      $45: Represents the 45th field  
      $NF: Stands for "number of fields" and represents the last field  
      ```

---------------
## - Regex

  * Special Atoms:  
      ```
      .        -   Indicates any character  
      ^        -   Indicates the start of the line  
      $        -   Indicates the end of the line  
      ```
  * Backslash sequence:  
      ```
      \< -\>   -   The empty string at the beginning - at the end of a word  
      \b       -   The empty string at the edge of a word  
      \B       -   The empty string provided it is not at the boundary of a word  
      \w       -   Any letter, number or _  
      \W       -   Any one not included in \w  
      ```
  * Multipliers:  
      ```
      {n,m}    -   From n to m occurrences of the atom that precedes it  
      ?        -   Zero or one occurrence of the atom that precedes it  
      *        -   Zero or more occurrences of the atom that precedes it  
      +        -   One or more occurrences of the atom that precedes it  
      ```
   * Charset:  
      ```
      [abc]    -   Any character between a, b or c  
      [a-z]    -   Any character between a and z inclusive  
      [^dc]    -   Any character that is neither d nor c  
      ```
   * Character class based charsets [:CLASS_NAME:], where CLASS_NAME:  
      ```
      alnum digit punct alpha graph space  
      blank lower upper cntrl print xdigit  
      ```

---------------
## - xargs

  * `xargs <command>` expects a list of strings on standard input, and it then invokes command with those strings as arguments  
  * Peculiarities of behavior:  
      * xargs groups the invocations in order to reduce the load. This can work with commands like ls, but not if the command accepts a single parameter  
      * xargs passes the input lines as they are on the command line built. The presence of spacers will therefore make the command perceive invoked a multiplicity of parameters
  * Options:  
      ```
      -0 (zero)      - Uses null, not space, as the argument terminator  
      -L MAX         - Use at most MAX input lines for each invocation  
      -p             - It asks interactively for confirmation of the launch of each command (useful to keep strings together)  
      ```
  * Ex: `pipeline | which produces | filenames | xargs ls -l` - Will run ls -l for each file received from the pipeline  
  * Ex: `cd /etc && echo passwd group | xargs ls -l` - Will run ls -l for each file received from the pipeline  


---------------
## - tee

  * Is a useful command for duplicating an output stream  
    * Send a copy of stdin to stdout  
    * Sends an identical copy in a file passed as a parameter  
    * `-a`    - The file is opened in append  
  * Ex: `command1 | tee FILE | command2`  

---------------
## - Process Substitution

  *  Pipe the stdout of multiple commands (Feeds the output of a process (or processes) into the stdin of another process)  
  *  Concurrently launches two processes where a pipe is used   
  *  There is no space between the the "<" or ">" and the parentheses  
  *  `cmd_consumer <(cmd_producer_on_stdout)`  
  *  `cmd_producer_on_file >(cmd_consumer_from_stdin)`  
  *  Examples:  
      ```
      bash$ less <(ls -l)   
         /dev/fo/12  - The pipe itself  
         
      bash$ cat <(date)  
         Thu Jul 21 12:40:53 EEST 2011  
      
      bash$ cat <(date) <(date) <(date)  
         Thu Jul 21 12:44:45 EEST 2011  
         Thu Jul 21 12:44:45 EEST 2011  
         Thu Jul 21 12:44:45 EEST 2011  
     
      bash$ echo <(date) <(date) <(date)  
         /proc/self/fd/11 /proc/self/fd/12 /proc/self/fd/13  

      bash$ wc <(cat /usr/share/dict/linux.words)  
       483523  483523 4992010 /dev/fd/63  

      bash$ grep script /usr/share/dict/linux.words | wc  
          262     262    3601  

      bash$ wc <(grep script /usr/share/dict/linux.words)  
          262     262    3601 /dev/fd/63  
      ```

---------------
## - Command Substitution

  * Command substitution allows the output of a command to replace the command itself  
  * Command substitution occurs when a command is enclosed as follows:  
    * `$(command)`  
    * `'command'`  
  * Bash performs the expansion by executing command in a subshell environment and replacing the command substitution with the standard output of the command  
  * Ex: `ls $(cat /etc/passwd | cut -f6 -d:)` - Extracts the home dirs of the users and sets them as parameters to ls  

---------------
## - Multiple Files Tools

### - diff
  * Allows you to show the differences between two files  
  * Special symbols:  
    * a : add  
    * c : change  
    * d : delete  
  * Example:  
      ```
      file1:            file2:  
      row one           row one  
      row two           row three  
      row three         row 4  
      row four          row five  
      row five          row 4bis  
      
      bash$ diff file1 file2  
         2d1  
         < row two  
         4c3  
         < row four  
         ---  
         > row 4  
         5a5  
         > row 5bis  
      ```
      
### - paste
  * Used to join files horizontally (parallel merging) by outputting lines consisting of lines from each file specified, separated by tab as delimiter, to the standard output  
  * When no file is specified, or put dash ("-") instead of file name, paste reads from standard input and gives output until a interrupt command [Ctrl-C] is given  
  * Ex: `paste file1 file2 file3`  

### - join
  * Same principle as paste, but join lines if they start with the same "Key" (needs files sorted identically on the selected key)  
  * Ex: `join file1 file2`  

---------------
## - Quoting

  * The wildcard expansion mechanism and variables is powerful but interferes with literal interpretation of some symbols such as: []!*?${}()"'\`\\|><;  
  * When you have to pass as a parameter to a command of strings containing such symbols, is required protect them from expansion  
  * Methods:  
      ```
      \   - (backslash) inhibits the interpretation of the character only next as special  
      '   - (apex) each character of a string enclosed in a apex pair is protected from expansion and treated literally, without exception  
      "   - (double apex or double quote) any character of a string enclosed in a pair of quotation marks is protected from the expansion,   
             with the exception of the $, of the backtick (`) of \, and other special cases  
      ```
  * Examples:  
      ```  
      \"       The backslash protects the quotes -> on the line remains "  
      '"'      As above, quotes protect quotes  
      \\       The first backslash protects the second -> on the line remains \  
      ```  
  * Interaction examples:  
      ```
      A=hello
      ls *\**           -  List filenames containing the * character in any position
      echo "$A"         -  Print the contents of variable A exactly (hello)
      echo '$A'         -  Print exactly $A
      echo "'$A'"       -  Print 'hello'
      
      bash$ echo $(ls)
         file1 file2
      bash$ echo "$(ls)"
         file1
         file2
      ```
---------------
## - Pathname Expansion  

 * Used interactively with file and directory management commands
 * The patterns are compared to the filesystem:  
   * If there are no files that match the pattern, the pattern remains unchanged on the command line  
   * if there are matching files, instead of the pattern are placed all their names, in alphabetical order  
 * Pattern:  
   * \*        - Represents any string of zero or more characters
   * ?         - Represents any single character
   * [SET]     - Represents any character belonging to SET:
     * A list, ex: `[afhOV]`  
     * An interval, ex: `[a-k]`  -  multiple intervals, ex: `[a-d, 0-5]`  
     * It can be denied with `!` o `^`, ex: `[!a]` `[^A-Z]`  
     * It can be a class like egrep, ex: `[[:alnum:]]`  
     * To include `-` or `]` in the SET, put them as the first character  

---------------
## - Brace Expansion  

 * Unlike pathname expansion, strings are generated independently regardless of whether or not there are files that match the pattern
 * Syntax: `[PRE]{LIST/SEQUENCE}[POST]`
 * List example: `a{d,c,b}e`  ->  expanded from the shell into `ade ace abe○`  
 * Sequence examples:  
     ```  
     file{9..13..2}.c   ->  file9.c file11.c file13.c    (..2 optional increment)    
     doc{009..11}       ->  doc009 doc010 doc011         (009 zero-padding)  
     {a..j..3}          ->  a d g j                      (a,j single alphabetic character only)  
     ```  
---------------
## - Variables  

 * A way offered by the shell to store text strings under a given name  
 * The modification/creation of a variable is obtained by indicating on the command line the name of the variable followed by = and the value to be attributed to it  
 * Ex: `NAME=value`
 * Parameter expansion is used to read the contents of a variable, ex: `$NAME`  
 * If NAME is compound or ambiguous, protect it with {}: `${NAME}`  

### - Environment Variables
  * Provide a simple way to share configuration settings between multiple applications and processes in Linux: `export varname`  
  * The current environment can be viewed with the `set` command
  * `env`   -  Print a list of the current environment variables

### - Notable Variables (for bash)
